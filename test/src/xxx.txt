namespace ZONED
{
    template <class charT, size_t N>
    class basic_fixed_string {
    public:
​///
      using value_type = charT;
      using view = basic_string_view<charT>;
      using size_type = view::size_type;
      using difference_type = view::difference_type;
      using reference       = value_type&;
      using const_reference = const value_type&;
      using pointer         = value_type*;
      using const_pointer   = const value_type*;
      using iterator               = pointer;
      using const_iterator         = const_pointer;
      using reverse_iterator       = std::reverse_iterator<iterator>;
      using const_reverse_iterator = std::reverse_iterator<const_iterator>;
      static constexpr size_type npos = view::npos;
​
// construct/copy/conversions
      constexpr basic_fixed_string() noexcept;
      constexpr basic_fixed_string(const basic_fixed_string& str) noexcept;
      constexpr basic_fixed_string(const charT(&arr)[N + 1]) noexcept;
      constexpr basic_fixed_string& operator=(const basic_fixed_string& str)
        noexcept;
      constexpr basic_fixed_string& operator=(const charT(&arr)[N + 1])
        noexcept;
      constexpr operator view() const noexcept;
​
 // iterators
      constexpr iterator       begin() noexcept;
      constexpr const_iterator begin() const noexcept;
      constexpr iterator       end() noexcept;
      constexpr const_iterator end() const noexcept;
      constexpr reverse_iterator       rbegin() noexcept;
      constexpr const_reverse_iterator rbegin() const noexcept;
      constexpr reverse_iterator       rend() noexcept;
      constexpr const_reverse_iterator rend() const noexcept;
      constexpr const_iterator         cbegin() const noexcept;
      constexpr const_iterator         cend() const noexcept;
      constexpr const_reverse_iterator crbegin() const noexcept;
      constexpr const_reverse_iterator crend() const noexcept;
​
   // capacity
      constexpr size_type size() const noexcept;
      constexpr size_type length() const noexcept;
      constexpr size_type max_size() const noexcept;
      constexpr size_type capacity() const noexcept;
      constexpr bool empty() const noexcept;
​
 // XY.N.M+3, element access
      constexpr const_reference operator[](size_type pos) const noexcept;
      constexpr reference operator[](size_type pos) noexcept;
      constexpr const_reference at(size_type pos) const noexcept;
      constexpr reference at(size_type pos) noexcept;
      constexpr const_reference front() const noexcept;
      constexpr reference front() noexcept;
      constexpr const_reference back() const noexcept;
      constexpr reference back() noexcept;
      // modifications
      constexpr basic_fixed_string& replace(size_t pos, view str);
      constexpr void swap(basic_fixed_string& str);
​
   // string operations
      constexpr const charT* c_str() const noexcept;
      constexpr const charT* data() const noexcept;
      constexpr size_type find(view str, size_type pos = 0) const noexcept;
      constexpr size_type find(const charT* s, size_type pos,
                               size_type n) const;
      constexpr size_type find(const charT* s, size_type pos = 0) const;
      constexpr size_type find(charT c, size_type pos = 0) const noexcept;
      constexpr size_type rfind(view str,
                                size_type pos = npos) const noexcept;
      constexpr size_type rfind(const charT* s, size_type pos,
                                size_type n) const;
      constexpr size_type rfind(const charT* s, size_type pos = npos) const;
      constexpr size_type rfind(charT c, size_type pos = npos) const;
      constexpr size_type find_first_of(view str,
                                        size_type pos = 0) const noexcept;
      constexpr size_type find_first_of(const charT* s, size_type pos,
                                        size_type n) const;
      constexpr size_type find_first_of(const charT* s,
                                        size_type pos = 0) const;
      constexpr size_type find_first_of(charT c, size_type pos = 0) const;
      constexpr size_type find_last_of(view str,
                                       size_type pos = npos) const noexcept;
      constexpr size_type find_last_of(const charT* s, size_type pos,
                                       size_type n) const;
      constexpr size_type find_last_of(const charT* s,
                                       size_type pos = npos) const;
      constexpr size_type find_last_of(charT c, size_type pos = npos) const;
      constexpr size_type find_first_not_of(view str, size_type pos = 0)
        const noexcept;
      constexpr size_type find_first_not_of(const charT* s, size_type pos,
                                            size_type n) const;
      constexpr size_type find_first_not_of(const charT* s,
                                            size_type pos = 0) const;
      constexpr size_type find_first_not_of(charT c, size_type pos = 0) const;
      constexpr size_type find_last_not_of(view str, size_type pos = npos)
        const noexcept;
      constexpr size_type find_last_not_of(const charT* s, size_type pos,
                                           size_type n) const;
      constexpr size_type find_last_not_of(const charT* s,
                                           size_type pos = npos) const;
      constexpr size_type find_last_not_of(charT c,
                                           size_type pos = npos) const;
      template <size_type pos = 0, size_type count = npos>
        constexpr basic_fixed_string<charT, /*...*/> substr() const noexcept;
      constexpr int compare(view str) const noexcept;
      constexpr int compare(size_type pos1, size_type n1, view str) const;
      constexpr int compare(size_type pos1, size_type n1, view str,
                            size_type pos2, size_type n2 = npos) const;
      constexpr int compare(const charT* s) const;
      constexpr int compare(size_type pos1, size_type n1,
                            const charT* s) const;
      constexpr int compare(size_type pos1, size_type n1, const charT* s,
                            size_type n2) const;
    private:
      charT data_[N + 1];  // exposition only
                           // (+1 is for terminating null)
    };

​
}  // namespace ZONED




namespace ZONED
{
  // 
​
Class template basic_fixed_string
  template <class charT, size_t N>
    class basic_fixed_string;
​
// basic_fixed_string non­member concatenation functions
  template <class charT, size_t L, size_t R>
    constexpr basic_fixed_string<charT, N + M>
      operator+(const basic_fixed_string<charT, L>& lhs,
                const basic_fixed_string<charT, R>& rhs) noexcept;
  template <class charT, size_t L, size_t R>
    constexpr basic_fixed_string<charT, N ­ 1 + M>
      operator+(const charT(&lhs)[L],
                const basic_fixed_string<charT, R>& rhs) noexcept;
  template <class charT, size_t N>
    constexpr basic_fixed_string<charT, N + 1>
      operator+(charT lhs,
                const basic_fixed_string<charT, R>& rhs) noexcept;
  template <class charT, size_t L, size_t R>
    constexpr basic_fixed_string<charT, N + M ­ 1>
      operator+(const basic_fixed_string<charT, L>& lhs,
                const charT(&rhs)[R]) noexcept;
  template <class charT, size_t N>
    constexpr basic_fixed_string<charT, N + 1>
      operator+(const basic_fixed_string<charT, L>& lhs,
                charT rhs) noexcept;
​
// basic_fixed_string non­member comparison functions
  template <class charT, size_t L, size_t R>
    constexpr bool operator==(const basic_fixed_string<charT, L>& lhs,
                              const basic_fixed_string<charT, R>& rhs)
      noexcept;
  template <class charT, size_t L, size_t R>
    constexpr bool operator==(const charT(&lhs)[L],
                              const basic_fixed_string<charT, R>& rhs)
      noexcept;
  template <class charT, size_t L, size_t R>
    constexpr bool operator==(const basic_fixed_string<charT, L>& lhs,
                              const charT(&rhs)[R]) noexcept;
  template <class charT, size_t L, size_t R>
    constexpr bool operator!=(const basic_fixed_string<charT, L>& lhs,
                              const basic_fixed_string<charT, R>& rhs)
      noexcept;
  template <class charT, size_t L, size_t R>
    constexpr bool operator!=(const charT(&lhs)[L],
                              const basic_fixed_string<charT, R>& rhs)
      noexcept;
  template <class charT, size_t L, size_t R>
    constexpr bool operator!=(const basic_fixed_string<charT, L>& lhs,
                              const charT(&rhs)[R]) noexcept;
  template <class charT, size_t L, size_t R>
    constexpr bool operator< (const basic_fixed_string<charT, L>& lhs,
                             const basic_fixed_string<charT, R>& rhs)
      noexcept;
  template <class charT, size_t L, size_t R>
    constexpr bool operator< (const charT(&lhs)[L],
                              const basic_fixed_string<charT, R>& rhs)
      noexcept;
  template <class charT, size_t L, size_t R>
    constexpr bool operator< (const basic_fixed_string<charT, L>& lhs,
                              const charT(&rhs)[R]) noexcept;
  template <class charT, size_t L, size_t R>
    constexpr bool operator> (const basic_fixed_string<charT, L>& lhs,
                              const basic_fixed_string<charT, R>& rhs)
      noexcept;
  template <class charT, size_t L, size_t R>
    constexpr bool operator> (const charT(&lhs)[L],
                              const basic_fixed_string<charT, R>& rhs)
      noexcept;
  template <class charT, size_t L, size_t R>
    constexpr bool operator> (const basic_fixed_string<charT, L>& lhs,
                              const charT(&rhs)[R]) noexcept;
  template <class charT, size_t L, size_t R>
    constexpr bool operator<=(const basic_fixed_string<charT, L>& lhs,
                              const basic_fixed_string<charT, R>& rhs)
      noexcept;
  template <class charT, size_t L, size_t R>
    constexpr bool operator<=(const charT(&lhs)[L],
                              const basic_fixed_string<charT, R>& rhs)
      noexcept;
  template <class charT, size_t L, size_t R>
    constexpr bool operator<=(const basic_fixed_string<charT, L>& lhs,
                              const charT(&rhs)[R]) noexcept;
  template <class charT, size_t L, size_t R>
    constexpr bool operator>=(const basic_fixed_string<charT, L>& lhs,
                              const basic_fixed_string<charT, R>& rhs)
      noexcept;
  template <class charT, size_t L, size_t R>
    constexpr bool operator>=(const charT(&lhs)[L],
                              const basic_fixed_string<charT, R>& rhs)
      noexcept;
  template <class charT, size_t L, size_t R>
    constexpr bool operator>=(const basic_fixed_string<charT, L>& lhs,
                              const charT(&rhs)[R]) noexcept;
​
// swap
  template <class charT, size_t N>
    constexpr void swap(basic_fixed_string<charT, L>& lhs,
                        basic_fixed_string<charT, N>& rhs) noexcept;
​
// basic_fixed_string type aliases
  template <size_t N>
    using fixed_string = basic_fixed_string<char, N>;
  template <size_t N>
    using fixed_u16string = basic_fixed_string<char16_t, N>;
  template <size_t N>
    using fixed_u32string = basic_fixed_string<char32_t, N>;
  template <size_t N>
    using fixed_wstring = basic_fixed_string<wchar_t, N>;
​
// numeric conversions:
  template <size_t N>
    constexpr int stoi(const fixed_string<N>& str, int base = 10);
  template <size_t N>
    constexpr unsigned stou(const fixed_string<N>& str, int base = 10);
  template <size_t N>
    constexpr long stol(const fixed_string<N>& str, int base = 10);
  template <size_t N>
    constexpr unsigned long stoul(const fixed_string<N>& str, int base = 10;
  template <size_t N>
    constexpr long long stoll(const fixed_string<N>& str, int base = 10);
  template <size_t N>
    constexpr unsigned long long stoull(const fixed_string<N>& str,
                                        int base = 10);
  template <size_t N>
    constexpr float stof(const fixed_string<N>& str);
  template <size_t N>
    constexpr double stod(const fixed_string<N>& str);
  template <size_t N>
    constexpr long double stold(const fixed_string<N>& str);
  template <int val>
    constexpr fixed_string</*...*/> to_fixed_string_i() noexcept;
  template <unsigned val>
    constexpr fixed_string</*...*/> to_fixed_string_u() noexcept;
  template <long val>
    constexpr fixed_string</*...*/> to_fixed_string_l() noexcept;
  template <unsigned long val>
    constexpr fixed_string</*...*/> to_fixed_string_ul() noexcept;
  template <long long val>
    constexpr fixed_string</*...*/> to_fixed_string_ll() noexcept;
  template <unsigned long long val>
    constexpr fixed_string</*...*/> to_fixed_string_ull() noexcept;
​
// XY.N+6, creation helper function
  template <class charT, size_t N>
    constexpr basic_fixed_string<charT, N ­ 1>
      make_fixed_string(const charT(&a)[N]) noexcept;

  }
